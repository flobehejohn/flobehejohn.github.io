// assets/js/player-singleton.js
// Lecteur audio persistant (singleton) + reprise après reload + compat PJAX.
// - Idempotent: ne s'initialise qu'une seule fois (window.AudioApp.initialized).
// - Sauvegarde/restaure l'état (src, time, volume, playing, index, title, cover).
// - Fallback de chemin playlist (absolu puis relatif) pour fonctionner en local comme en prod.
// - Throttle des écritures sessionStorage pour limiter la pression I/O.
// - Politique audio par page via <meta name="audio-policy" content="pause"> (pause forcée).
//   -> Reprise automatique sur pages "allow" (sans meta) au timecode snapshoté.

(() => {
    if (window.AudioApp?.initialized) {
      // Déjà initialisé (ex: après navigation PJAX) -> on sort.
      return;
    }
  
    // ————————————————————————————————————————————————
    // RÉFÉRENCES DOM
    // ————————————————————————————————————————————————
    const player       = document.getElementById("audioPlayer");
    const playBtn      = document.getElementById("toggleBtn");
    const stopBtn      = document.getElementById("stopBtn");
    const nextBtn      = document.getElementById("nextBtn");
    const prevBtn      = document.getElementById("prevBtn");
    const progress     = document.getElementById("progress");
    const volume       = document.getElementById("volume");
    const timeDisplay  = document.getElementById("timeDisplay");
    const trackTitle   = document.getElementById("trackTitle");
    const cover        = document.getElementById("cover");
    const infoPanel    = document.getElementById("infoPanel");
    const logo         = document.querySelector(".navbar-brand img");
    const toggleButton = document.getElementById("openAudioPlayer");
    const modalEl      = document.getElementById("audioPlayerModal");
    const closeBtn     = document.getElementById("closePlayerModal");
    const dragBar      = document.getElementById("dragBar");
  
    if (!player) {
      // Rien à faire si l'élément <audio> est absent.
      return;
    }
  
    // ————————————————————————————————————————————————
    // POLITIQUE AUDIO PAR PAGE (meta[name="audio-policy"])
    // ————————————————————————————————————————————————
    const KEY_FORCED = "audioForcedState"; // { src, t, wasPlaying }
  
    function currentPolicy() {
      const meta = document.querySelector('meta[name="audio-policy"]');
      return meta ? (meta.content || "").toLowerCase() : "allow";
    }
  
    function pauseForPolicy() {
      const wasPlaying = !player.paused && !player.ended && (player.currentTime || 0) > 0;
      const snap = { src: player.currentSrc || player.src || "", t: player.currentTime || 0, wasPlaying };
      try { sessionStorage.setItem(KEY_FORCED, JSON.stringify(snap)); } catch {}
      try { player.pause(); } catch {}
    }
  
    async function resumeIfForcedAllowed() {
      let raw; try { raw = sessionStorage.getItem(KEY_FORCED); } catch {}
      if (!raw) return;
      let s; try { s = JSON.parse(raw); } catch { s = null; }
      if (!s || !s.wasPlaying) { try { sessionStorage.removeItem(KEY_FORCED); } catch {}; return; }
  
      try {
        if (s.src && player.src !== s.src) player.src = s.src;
        if (s.t) player.currentTime = s.t;
        await player.play().catch(() => {}); // ignore si autoplay bloqué
      } finally {
        try { sessionStorage.removeItem(KEY_FORCED); } catch {}
      }
    }
  
    function applyAudioPolicy() {
      const p = currentPolicy();
      if (p === "pause" || p === "mute" || p === "block") pauseForPolicy();
      else resumeIfForcedAllowed();
    }
  
    // Appliquer la politique :
    // - à la 1ère charge
    // - après chaque navigation PJAX
    // - à l’événement pageshow (retour BFCache)
    window.addEventListener("DOMContentLoaded", applyAudioPolicy);
    document.addEventListener("pjax:ready", applyAudioPolicy);
    window.addEventListener("pageshow", applyAudioPolicy);
  
    // ————————————————————————————————————————————————
    // ÉTAT INTERNE
    // ————————————————————————————————————————————————
    let playlist      = [];
    let trackIndex    = 0;
    let playlistReady = false;
  
    // throttle sessionStorage
    let _lastSave = 0;
    const SAVE_MS = 800;
    function throttleSave(fn) {
      const now = (typeof performance !== "undefined" && performance.now) ? performance.now() : Date.now();
      if (now - _lastSave > SAVE_MS) {
        _lastSave = now;
        try { fn(); } catch {}
      }
    }
  
    // ————————————————————————————————————————————————
    // PERSISTANCE (sessionStorage)
    //   Schéma courant: { src, time, volume, playing, index, title, coverSrc }
    //   Rétro-compat: accepte { t, paused } si présents (anciens snippets).
    // ————————————————————————————————————————————————
    function restoreSession() {
      try {
        const raw = sessionStorage.getItem("audioState");
        if (!raw) return false;
  
        const s = JSON.parse(raw);
        // rétro-compat champs
        const src     = s.src || "";
        const time    = typeof s.time === "number" ? s.time : (typeof s.t === "number" ? s.t : 0);
        const playing = typeof s.playing === "boolean" ? s.playing : (typeof s.paused === "boolean" ? !s.paused : false);
        const vol     = typeof s.volume === "number" ? s.volume : undefined;
        const index   = typeof s.index === "number" ? s.index : undefined;
        const title   = s.title || "";
        const coverSrc= s.coverSrc || "";
  
        if (index !== undefined) trackIndex = index;
  
        if (src) {
          // Assigne la source si différente
          if (player.src !== src) player.src = src;
        }
  
        if (vol !== undefined) {
          player.volume = Math.max(0, Math.min(1, vol));
          if (volume) volume.value = String(Math.round(player.volume * 100));
        }
  
        if (trackTitle && title) trackTitle.textContent = title;
        const img = cover?.querySelector("img");
        if (img && coverSrc) img.src = coverSrc;
  
        // Positionnement du temps: attendre les métadonnées si besoin
        const setTime = (t) => {
          if (!t || t < 0.2) return;
          try { player.currentTime = t; } catch {}
        };
        if (player.readyState >= 1) {
          setTime(time);
        } else {
          const once = () => {
            player.removeEventListener("loadedmetadata", once);
            setTime(time);
          };
          player.addEventListener("loadedmetadata", once);
        }
  
        // Reprise lecture si c'était en cours (respect des règles d'autoplay du navigateur)
        if (playing) {
          player.play().then(() => {
            playBtn?.classList.add("playing");
            cover?.classList.add("playing");
            infoPanel?.classList.add("open");
            if (toggleButton) toggleButton.classList.add("playing", "large");
            if (logo) logo.classList.add("glow-on-play");
          }).catch(() => { /* silencieux (policy autoplay) */ });
        }
  
        return true;
      } catch {
        return false;
      }
    }
  
    function saveSession(force = false) {
      const doSave = () => {
        const st = {
          src: player.currentSrc || player.src || "",
          time: player.currentTime || 0,
          volume: player.volume,
          playing: !player.paused,
          index: trackIndex,
          title: trackTitle?.textContent || "",
          coverSrc: cover?.querySelector("img")?.src || ""
        };
        sessionStorage.setItem("audioState", JSON.stringify(st));
      };
  
      if (force) {
        try { doSave(); } catch {}
        return;
      }
      throttleSave(doSave);
    }
  
    window.addEventListener("beforeunload", () => saveSession(true));
  
    // ————————————————————————————————————————————————
    // CHARGEMENT PLAYLIST
    // ————————————————————————————————————————————————
    const PLAYLIST_CANDIDATES = [
      "/assets/audio/auto_radio/js/playlist.json",   // prod GitHub Pages (user site)
      "/assets/audio/auto_radio/js/playlist.json"     // fallback relatif (dev local/serveur)
    ];
  
    async function fetchFirstOk(urls) {
      let lastErr;
      for (const u of urls) {
        try {
          const res = await fetch(u, { cache: "force-cache" });
          if (res.ok) return res.json();
          lastErr = new Error(`HTTP ${res.status} on ${u}`);
        } catch (e) { lastErr = e; }
      }
      throw lastErr || new Error("Aucun chemin playlist disponible");
    }
  
    async function loadPlaylist() {
      try {
        const data = await fetchFirstOk(PLAYLIST_CANDIDATES);
        if (!Array.isArray(data) || data.length === 0) {
          throw new Error("Playlist vide ou mal formée.");
        }
  
        playlist = data;
        playlistReady = true;
  
        // Si aucune session n'existe, démarre sur une piste aléatoire (sans autoplay)
        const hadState = !!sessionStorage.getItem("audioState");
        if (!hadState) {
          trackIndex = Math.floor(Math.random() * playlist.length);
          setTrack(trackIndex, false);
        } else {
          // Session déjà restaurée plus haut (src/time/volume). Assure juste l'UI (titre/couverture) si absent.
          const t = playlist[trackIndex];
          if (t) {
            if (trackTitle && !trackTitle.textContent) trackTitle.textContent = t.title || "";
            const img = cover?.querySelector("img");
            if (img && (!img.src || img.src.startsWith("data:"))) img.src = t.cover || img.src;
          }
        }
      } catch (error) {
        console.error("Erreur de chargement de la playlist :", error);
        if (trackTitle) trackTitle.textContent = "Erreur de chargement de la playlist.";
      }
    }
  
    // ————————————————————————————————————————————————
    // DÉFINIR UNE PISTE
    // ————————————————————————————————————————————————
    function setTrack(i, play = true) {
      if (!playlistReady || !playlist[i]) return;
  
      trackIndex = i;
      const track = playlist[i];
  
      if (track?.src) player.src = track.src;
      if (trackTitle) trackTitle.textContent = track?.title || "";
      const img = cover?.querySelector("img");
      if (img && track?.cover) img.src = track.cover;
  
      if (play) {
        player.play()
          .then(() => {
            playBtn?.classList.add("playing");
            cover?.classList.add("playing");
            infoPanel?.classList.add("open");
            toggleButton?.classList.add("playing", "large");
            if (logo) logo.classList.add("glow-on-play");
            saveSession(true);
          })
          .catch((err) => {
            console.error("Erreur de lecture :", err);
            saveSession(true);
          });
      } else {
        saveSession(true);
      }
    }
  
    // ————————————————————————————————————————————————
    // CONTRÔLES (idempotents)
    // ————————————————————————————————————————————————
    const onToggle = () => {
      if (!playlistReady && !player.src) return;
  
      if (player.paused) {
        player.play()
          .then(() => {
            playBtn?.classList.add("playing");
            cover?.classList.add("playing");
            infoPanel?.classList.add("open");
            toggleButton?.classList.add("playing", "large");
            if (logo) logo.classList.add("glow-on-play");
            playBtn?.setAttribute("aria-pressed", "true");
            saveSession();
          })
          .catch((err) => console.error("Erreur de lecture :", err));
      } else {
        player.pause();
        playBtn?.classList.remove("playing");
        cover?.classList.remove("playing");
        infoPanel?.classList.remove("open");
        toggleButton?.classList.remove("playing", "large");
        if (logo) logo.classList.remove("glow-on-play");
        playBtn?.setAttribute("aria-pressed", "false");
        saveSession();
      }
    };
    playBtn?.addEventListener("click", onToggle);
  
    const onStop = () => {
      if (!playlistReady && !player.src) return;
      player.pause();
      try { player.currentTime = 0; } catch {}
      playBtn?.classList.remove("playing");
      cover?.classList.remove("playing");
      infoPanel?.classList.remove("open");
      toggleButton?.classList.remove("playing", "large");
      if (logo) logo.classList.remove("glow-on-play");
      saveSession(true);
    };
    stopBtn?.addEventListener("click", onStop);
  
    const onNext = () => {
      if (!playlistReady || !playlist.length) return;
      trackIndex = (trackIndex + 1) % playlist.length;
      setTrack(trackIndex);
    };
    nextBtn?.addEventListener("click", onNext);
  
    const onPrev = () => {
      if (!playlistReady || !playlist.length) return;
      trackIndex = (trackIndex - 1 + playlist.length) % playlist.length;
      setTrack(trackIndex);
    };
    prevBtn?.addEventListener("click", onPrev);
  
    // ————————————————————————————————————————————————
    // PROGRESSION + TEMPS + VOLUME
    // ————————————————————————————————————————————————
    player.addEventListener("timeupdate", () => {
      if (player.duration && progress) {
        try {
          const v = (player.currentTime / player.duration) * 100;
          if (!Number.isNaN(v)) progress.value = String(v);
        } catch {}
      }
      if (timeDisplay) {
        const m = Math.floor(player.currentTime / 60);
        const s = Math.floor(player.currentTime % 60).toString().padStart(2, "0");
        timeDisplay.textContent = `${m}:${s}`;
      }
      saveSession(); // throttled
    });
  
    progress?.addEventListener("input", (e) => {
      if (!player.duration) return;
      const raw = (e.target.valueAsNumber ?? parseFloat(e.target.value));
      if (Number.isFinite(raw)) {
        const clamped = Math.max(0, Math.min(100, raw));
        try { player.currentTime = (clamped / 100) * player.duration; } catch {}
        saveSession();
      }
    });
  
    // Volume par défaut (synchro avec le slider si présent)
    if (typeof player.volume === "number" && !Number.isNaN(player.volume)) {
      if (volume && typeof volume.value === "string" && volume.value !== "") {
        const v = parseInt(volume.value, 10);
        if (Number.isFinite(v)) player.volume = Math.max(0, Math.min(1, v / 100));
      }
    }
    volume?.addEventListener("input", (e) => {
      const v = e.target.valueAsNumber ?? parseInt(e.target.value, 10);
      if (Number.isFinite(v)) {
        player.volume = Math.max(0, Math.min(1, v / 100));
        saveSession();
      }
    });
  
    // ————————————————————————————————————————————————
    // ÉTATS VISUELS + FIN DE PISTE
    // ————————————————————————————————————————————————
    player.addEventListener("play", () => {
      toggleButton?.classList.add("playing", "large");
      if (logo) logo.classList.add("glow-on-play");
      playBtn?.classList.add("playing");
      cover?.classList.add("playing");
      infoPanel?.classList.add("open");
      playBtn?.setAttribute("aria-pressed", "true");
      saveSession();
    });
  
    player.addEventListener("pause", () => {
      toggleButton?.classList.remove("playing", "large");
      if (logo) logo.classList.remove("glow-on-play");
      playBtn?.classList.remove("playing");
      cover?.classList.remove("playing");
      infoPanel?.classList.remove("open");
      playBtn?.setAttribute("aria-pressed", "false");
      saveSession();
    });
  
    player.addEventListener("ended", () => {
      toggleButton?.classList.remove("playing", "large");
      if (logo) logo.classList.remove("glow-on-play");
      if (!playlistReady || !playlist.length) return;
      trackIndex = (trackIndex + 1) % playlist.length;
      setTrack(trackIndex);
    });
  
    // ————————————————————————————————————————————————
    // MODALE OUVERTURE/FERMETURE
    // ————————————————————————————————————————————————
    const openModal  = () => modalEl?.classList.add("open");
    const closeModal = () => modalEl?.classList.remove("open");
    toggleButton?.addEventListener("click", openModal);
    closeBtn?.addEventListener("click", closeModal);
  
    // ————————————————————————————————————————————————
    // DRAG MODALE (optionnel)
    // ————————————————————————————————————————————————
    (function enableDrag() {
      if (!dragBar || !modalEl) return;
      let dragging = false, startX=0, startY=0, startLeft=0, startTop=0;
  
      dragBar.addEventListener("mousedown", (e) => {
        dragging = true;
        startX = e.clientX; startY = e.clientY;
        const rect = modalEl.getBoundingClientRect();
        startLeft = rect.left; startTop = rect.top;
        document.body.classList.add("dragging");
      });
  
      window.addEventListener("mousemove", (e) => {
        if (!dragging) return;
        const dx = e.clientX - startX, dy = e.clientY - startY;
        modalEl.style.left = `${startLeft + dx}px`;
        modalEl.style.top  = `${startTop  + dy}px`;
        modalEl.style.position = "fixed";
      });
  
      window.addEventListener("mouseup", () => {
        dragging = false;
        document.body.classList.remove("dragging");
      });
    })();
  
    // ————————————————————————————————————————————————
    // INIT : tenter de restaurer l'état PUIS charger la playlist
    // ————————————————————————————————————————————————
    // 1) Restaure tout de suite si possible (src/time/volume/playing)
    const hadSession = restoreSession();
  
    // 2) Charge la playlist (nécessaire de toute façon pour next/prev)
    loadPlaylist();
  
    // ————————————————————————————————————————————————
    // API GLOBALE (debug/contrôle externe)
    // ————————————————————————————————————————————————
    window.AudioApp = {
      initialized: true,
      next: onNext,
      prev: onPrev,
      playPause: onToggle,
      stop: onStop,
      setTrack,
      open: openModal,
      close: closeModal
    };
  })();
  